{"ast":null,"code":"import _toConsumableArray from\"/Users/bubird/Documents/GitHub/pomodoer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _objectSpread from\"/Users/bubird/Documents/GitHub/pomodoer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _slicedToArray from\"/Users/bubird/Documents/GitHub/pomodoer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useEffect,useRef,useState}from'react';import socketIOClient from'socket.io-client';var NEW_TASK_EVENT='newTaskItem';//for heroku\n// const SOCKET_SERVER_URL = 'https://pomodoer.herokuapp.com/';\n//for local environ.\nvar SOCKET_SERVER_URL='http://localhost:5000';var STATUS_CHANGE='statusChange';var CLEAR_COMPLETE='clearCompleteTasks';var SENDING_USER_ID='sendId';var useList=function useList(roomId){var _useState=useState([]),_useState2=_slicedToArray(_useState,2),tasks=_useState2[0],setTasks=_useState2[1];var _useState3=useState([]),_useState4=_slicedToArray(_useState3,2),statuses=_useState4[0],setStatuses=_useState4[1];var socketRef=useRef();// console.log('tasks after useList called', tasks)\nuseEffect(function(){console.log('creating new websocket connection');// creates websocket connection\nsocketRef.current=socketIOClient(SOCKET_SERVER_URL,{query:{roomId:roomId}});// listens for incoming tasks\nsocketRef.current.on(NEW_TASK_EVENT,function(task){var incomingTask=_objectSpread(_objectSpread({},task),{},{ownedByCurrentUser:task.senderId===socketRef.current.id});//adds task to tasks list, adds corresponding status to statuses\nsetTasks(function(tasks){return[].concat(_toConsumableArray(tasks),[incomingTask]);});var copy=_toConsumableArray(statuses);copy.push(false);setStatuses(function(statuses){return[].concat(_toConsumableArray(statuses),[false]);});});// listens for population \nsocketRef.current.on('populate',function(data){// console.log('populate',data)\n// console.log(data.length)\nvar savedTasks=_toConsumableArray(tasks);for(var i=0;i<data.length;i++){savedTasks.push(data[i]);}for(var _i=0;_i<savedTasks.length;_i++){if(savedTasks[_i].senderId===socketRef.current.id){savedTasks[_i].ownedByCurrentUser=true;}else{savedTasks[_i].ownedByCurrentUser=false;}}// console.log('saved tasks', savedTasks)\nsetTasks(savedTasks);});// listens for status changes\nsocketRef.current.on(STATUS_CHANGE,function(data){var copy=_toConsumableArray(data.status);copy[data.index]=!copy[data.index];setStatuses(copy);});// listens for connection\nsocketRef.current.on('connect',function(){// console.log(socketRef.current.id)\nsendId(socketRef.current.id);//maybe add population in here?\n});// socketRef.current.on(SENDING_USER_ID, (data) => {\n//     console.log('listening for sending user id', data)\n// })\n// listens for clear \nsocketRef.current.on(CLEAR_COMPLETE,function(data){var indices=[];var statusesCopy=[];for(var i=0;i<data.status.length;i++){if(data.status[i]===true){indices.push(i);}else{statusesCopy.push(false);}}setStatuses(statusesCopy);// setCompleteIndices(indices)\n// using indices to delete corresponding tasks\nvar copy=_toConsumableArray(data.tasks);for(var _i2=indices.length-1;_i2>-1;_i2--){copy.splice(indices[_i2],1);}// corrects owner association\nfor(var _i3=0;_i3<copy.length;_i3++){if(copy[_i3].senderId===socketRef.current.id){copy[_i3].ownedByCurrentUser=true;}else{copy[_i3].ownedByCurrentUser=false;}}setTasks(copy);});// destroy socket reference when the connection is closed\nreturn function(){socketRef.current.disconnect();};},[roomId]);//sends message to server that forwards to all users in room\nvar sendTask=function sendTask(taskBody){socketRef.current.emit(NEW_TASK_EVENT,{body:taskBody,senderId:socketRef.current.id,statuses:statuses});};// sends user Id to server\nvar sendId=function sendId(userId){socketRef.current.emit(SENDING_USER_ID,{userId:userId});};//sends status change to server\nvar sendStatus=function sendStatus(index,statuses){socketRef.current.emit(STATUS_CHANGE,{index:index,status:statuses});};//sends clear notif to server\nvar sendClear=function sendClear(statuses,tasks){socketRef.current.emit(CLEAR_COMPLETE,{status:statuses,tasks:tasks});};// const populateTasks = (tasks) => {\n//     socketRef.current.emit('populate', {\n//         tasks:tasks,\n//     })\n// }\nreturn{tasks:tasks,sendTask:sendTask,statuses:statuses,sendStatus:sendStatus,sendClear:sendClear};};export default useList;","map":{"version":3,"sources":["/Users/bubird/Documents/GitHub/pomodoer/src/useList.js"],"names":["useEffect","useRef","useState","socketIOClient","NEW_TASK_EVENT","SOCKET_SERVER_URL","STATUS_CHANGE","CLEAR_COMPLETE","SENDING_USER_ID","useList","roomId","tasks","setTasks","statuses","setStatuses","socketRef","console","log","current","query","on","task","incomingTask","ownedByCurrentUser","senderId","id","copy","push","data","savedTasks","i","length","status","index","sendId","indices","statusesCopy","splice","disconnect","sendTask","taskBody","emit","body","userId","sendStatus","sendClear"],"mappings":"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","sourcesContent":["import {useEffect, useRef, useState} from 'react';\nimport socketIOClient from 'socket.io-client';\n\nconst NEW_TASK_EVENT = 'newTaskItem';\n\n//for heroku\n// const SOCKET_SERVER_URL = 'https://pomodoer.herokuapp.com/';\n//for local environ.\nconst SOCKET_SERVER_URL = 'http://localhost:5000';\n\nconst STATUS_CHANGE = 'statusChange'\nconst CLEAR_COMPLETE = 'clearCompleteTasks'\nconst SENDING_USER_ID = 'sendId'\nconst useList = (roomId) => {\n    const [tasks, setTasks] = useState([]);\n    const [statuses, setStatuses] = useState([]);\n    const socketRef = useRef();\n    // console.log('tasks after useList called', tasks)\n\n    useEffect(()=> {\n        console.log('creating new websocket connection');\n        // creates websocket connection\n        socketRef.current = socketIOClient(SOCKET_SERVER_URL, {\n            query:{roomId},\n        });\n\n        // listens for incoming tasks\n        socketRef.current.on(NEW_TASK_EVENT, (task) => {\n            const incomingTask = {\n                ...task,\n                ownedByCurrentUser: task.senderId === socketRef.current.id\n            };\n\n            //adds task to tasks list, adds corresponding status to statuses\n            setTasks((tasks) => [...tasks, incomingTask])\n            const copy = [...statuses];\n            copy.push(false);\n            setStatuses((statuses) => [...statuses, false])\n\n        });\n\n\n        // listens for population \n        socketRef.current.on('populate', (data) => {\n\n            // console.log('populate',data)\n            // console.log(data.length)\n\n            const savedTasks = [...tasks]\n            for (let i=0; i < data.length; i++) {\n                savedTasks.push(data[i])\n            }\n\n            for (let i=0; i<savedTasks.length; i++) {\n                if (savedTasks[i].senderId === socketRef.current.id) {\n                    savedTasks[i].ownedByCurrentUser = true\n                } else { \n                    savedTasks[i].ownedByCurrentUser = false\n                }\n            }\n\n\n            // console.log('saved tasks', savedTasks)\n            setTasks(savedTasks);\n                \n    \n            \n        })\n\n        // listens for status changes\n        socketRef.current.on(STATUS_CHANGE, (data) => {\n            const copy = [...data.status]\n            copy[data.index] = !copy[data.index];\n            setStatuses(copy);\n        })\n\n        // listens for connection\n        socketRef.current.on('connect', ()=>{\n            // console.log(socketRef.current.id)\n            sendId(socketRef.current.id)\n            //maybe add population in here?\n\n        });\n\n        // socketRef.current.on(SENDING_USER_ID, (data) => {\n        //     console.log('listening for sending user id', data)\n        // })\n\n        // listens for clear \n        socketRef.current.on(CLEAR_COMPLETE, (data) => {\n            const indices = []\n            const statusesCopy = []\n            for (let i=0; i < data.status.length; i++) {\n                if (data.status[i] === true) {\n                    indices.push(i)\n                } else {\n                    statusesCopy.push(false)\n                }\n            }\n\n            setStatuses(statusesCopy)\n            // setCompleteIndices(indices)\n            \n\n            // using indices to delete corresponding tasks\n            const copy = [...data.tasks]\n            for (let i=indices.length-1; i>(-1);i--) {\n                copy.splice(indices[i],1)\n            }\n            \n            // corrects owner association\n            for (let i=0; i<copy.length; i++) {\n                if (copy[i].senderId === socketRef.current.id) {\n                    copy[i].ownedByCurrentUser = true\n                } else { \n                    copy[i].ownedByCurrentUser = false\n                }\n            }\n\n            setTasks(copy);\n        })\n\n        // destroy socket reference when the connection is closed\n        return () => {\n            socketRef.current.disconnect();\n        };\n    }, [roomId]);\n\n    //sends message to server that forwards to all users in room\n    const sendTask = (taskBody) => {\n        socketRef.current.emit(NEW_TASK_EVENT, {\n            body: taskBody,\n            senderId: socketRef.current.id,\n            statuses: statuses\n        });\n    }\n\n    // sends user Id to server\n    const sendId = (userId) => {\n        socketRef.current.emit(SENDING_USER_ID, {\n            userId: userId\n        });\n    }\n\n    //sends status change to server\n    const sendStatus = (index,statuses) => {\n        socketRef.current.emit(STATUS_CHANGE, {\n            index: index,\n            status: statuses,\n        })\n    }\n\n    //sends clear notif to server\n    const sendClear = (statuses,tasks) => {\n        socketRef.current.emit(CLEAR_COMPLETE, {\n            status: statuses,\n            tasks: tasks,\n        }) \n    }\n\n    // const populateTasks = (tasks) => {\n    //     socketRef.current.emit('populate', {\n    //         tasks:tasks,\n    //     })\n    // }\n\n\n    return {tasks, sendTask, statuses, sendStatus, sendClear}\n}\n\nexport default useList"]},"metadata":{},"sourceType":"module"}