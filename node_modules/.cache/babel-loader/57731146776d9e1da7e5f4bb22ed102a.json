{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useRef, useState } from 'react';\nimport socketIOClient from 'socket.io-client';\nconst NEW_TASK_EVENT = 'newTaskItem'; //for heroku\n// const SOCKET_SERVER_URL = 'https://pomodoer.herokuapp.com/';\n//for local environ.\n\nconst SOCKET_SERVER_URL = 'http://localhost:5000';\nconst STATUS_CHANGE = 'statusChange';\nconst CLEAR_COMPLETE = 'clearCompleteTasks';\nconst SENDING_USER_ID = 'sendId';\n\nconst useList = roomId => {\n  _s();\n\n  const [tasks, setTasks] = useState([]);\n  const [statuses, setStatuses] = useState([]);\n  const socketRef = useRef();\n  console.log('tasks after useList called', tasks);\n  useEffect(() => {\n    console.log('creating new websocket connection'); // creates websocket connection\n\n    socketRef.current = socketIOClient(SOCKET_SERVER_URL, {\n      query: {\n        roomId\n      }\n    }); // listens for incoming tasks\n\n    socketRef.current.on(NEW_TASK_EVENT, task => {\n      const incomingTask = { ...task,\n        ownedByCurrentUser: task.senderId === socketRef.current.id\n      }; //adds task to tasks list, adds corresponding status to statuses\n\n      setTasks(tasks => [...tasks, incomingTask]);\n      const copy = [...statuses];\n      copy.push(false);\n      setStatuses(statuses => [...statuses, false]);\n    }); // listens for population \n\n    socketRef.current.on('populate', data => {\n      console.log('populate', data);\n      console.log('data body', data[0].body);\n      console.log(data.length);\n      const savedTasks = [...tasks];\n\n      for (let i = 0; i < data.length; i++) {\n        savedTasks.push(data[i]);\n      }\n\n      console.log('saved tasks', savedTasks);\n      setTasks(savedTasks);\n    }); // listens for status changes\n\n    socketRef.current.on(STATUS_CHANGE, data => {\n      const copy = [...data.status];\n      copy[data.index] = !copy[data.index];\n      setStatuses(copy);\n    }); // listens for connection\n\n    socketRef.current.on('connect', () => {\n      console.log(socketRef.current.id);\n      sendId(socketRef.current.id); //maybe add population in here?\n    }); // socketRef.current.on(SENDING_USER_ID, (data) => {\n    //     console.log('listening for sending user id', data)\n    // })\n    // listens for clear \n\n    socketRef.current.on(CLEAR_COMPLETE, data => {\n      const indices = [];\n      const statusesCopy = [];\n\n      for (let i = 0; i < data.status.length; i++) {\n        if (data.status[i] === true) {\n          indices.push(i);\n        } else {\n          statusesCopy.push(false);\n        }\n      }\n\n      setStatuses(statusesCopy); // setCompleteIndices(indices)\n      // using indices to delete corresponding tasks\n\n      const copy = [...data.tasks];\n\n      for (let i = indices.length - 1; i > -1; i--) {\n        copy.splice(indices[i], 1);\n      }\n\n      setTasks(copy);\n    }); // destroy socket reference when the connection is closed\n\n    return () => {\n      socketRef.current.disconnect();\n    };\n  }, [roomId]); //sends message to server that forwards to all users in room\n\n  const sendTask = taskBody => {\n    socketRef.current.emit(NEW_TASK_EVENT, {\n      body: taskBody,\n      senderId: socketRef.current.id,\n      statuses: statuses\n    });\n  }; // sends user Id to server\n\n\n  const sendId = userId => {\n    socketRef.current.emit(SENDING_USER_ID, {\n      userId: userId\n    });\n  }; //sends status change to server\n\n\n  const sendStatus = (index, statuses) => {\n    socketRef.current.emit(STATUS_CHANGE, {\n      index: index,\n      status: statuses\n    });\n  }; //sends clear notif to server\n\n\n  const sendClear = (statuses, tasks) => {\n    socketRef.current.emit(CLEAR_COMPLETE, {\n      status: statuses,\n      tasks: tasks\n    });\n  }; // const populateTasks = (tasks) => {\n  //     socketRef.current.emit('populate', {\n  //         tasks:tasks,\n  //     })\n  // }\n\n\n  return {\n    tasks,\n    sendTask,\n    statuses,\n    sendStatus,\n    sendClear\n  };\n};\n\n_s(useList, \"+Cdu3PuPr47Dy81IvNTZSE/U0ac=\");\n\nexport default useList;","map":{"version":3,"sources":["/Users/bubird/Documents/GitHub/pomodoer/src/useList.js"],"names":["useEffect","useRef","useState","socketIOClient","NEW_TASK_EVENT","SOCKET_SERVER_URL","STATUS_CHANGE","CLEAR_COMPLETE","SENDING_USER_ID","useList","roomId","tasks","setTasks","statuses","setStatuses","socketRef","console","log","current","query","on","task","incomingTask","ownedByCurrentUser","senderId","id","copy","push","data","body","length","savedTasks","i","status","index","sendId","indices","statusesCopy","splice","disconnect","sendTask","taskBody","emit","userId","sendStatus","sendClear"],"mappings":"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","sourcesContent":["import {useEffect, useRef, useState} from 'react';\nimport socketIOClient from 'socket.io-client';\n\nconst NEW_TASK_EVENT = 'newTaskItem';\n\n//for heroku\n// const SOCKET_SERVER_URL = 'https://pomodoer.herokuapp.com/';\n//for local environ.\nconst SOCKET_SERVER_URL = 'http://localhost:5000';\n\nconst STATUS_CHANGE = 'statusChange'\nconst CLEAR_COMPLETE = 'clearCompleteTasks'\nconst SENDING_USER_ID = 'sendId'\nconst useList = (roomId) => {\n    const [tasks, setTasks] = useState([]);\n    const [statuses, setStatuses] = useState([]);\n    const socketRef = useRef();\n    console.log('tasks after useList called', tasks)\n\n    useEffect(()=> {\n        console.log('creating new websocket connection');\n        // creates websocket connection\n        socketRef.current = socketIOClient(SOCKET_SERVER_URL, {\n            query:{roomId},\n        });\n\n        // listens for incoming tasks\n        socketRef.current.on(NEW_TASK_EVENT, (task) => {\n            const incomingTask = {\n                ...task,\n                ownedByCurrentUser: task.senderId === socketRef.current.id\n            };\n\n            //adds task to tasks list, adds corresponding status to statuses\n            setTasks((tasks) => [...tasks, incomingTask])\n            const copy = [...statuses];\n            copy.push(false);\n            setStatuses((statuses) => [...statuses, false])\n\n        });\n\n\n        // listens for population \n        socketRef.current.on('populate', (data) => {\n\n            console.log('populate',data)\n            console.log('data body',data[0].body)\n            console.log(data.length)\n\n            const savedTasks = [...tasks]\n            for (let i=0; i < data.length; i++) {\n                savedTasks.push(data[i])\n            }\n            console.log('saved tasks', savedTasks)\n            setTasks(savedTasks);\n                \n    \n            \n        })\n\n        // listens for status changes\n        socketRef.current.on(STATUS_CHANGE, (data) => {\n            const copy = [...data.status]\n            copy[data.index] = !copy[data.index];\n            setStatuses(copy);\n        })\n\n        // listens for connection\n        socketRef.current.on('connect', ()=>{\n            console.log(socketRef.current.id)\n            sendId(socketRef.current.id)\n            //maybe add population in here?\n\n        });\n\n        // socketRef.current.on(SENDING_USER_ID, (data) => {\n        //     console.log('listening for sending user id', data)\n        // })\n\n        // listens for clear \n        socketRef.current.on(CLEAR_COMPLETE, (data) => {\n            const indices = []\n            const statusesCopy = []\n            for (let i=0; i < data.status.length; i++) {\n                if (data.status[i] === true) {\n                    indices.push(i)\n                } else {\n                    statusesCopy.push(false)\n                }\n            }\n\n            setStatuses(statusesCopy)\n            // setCompleteIndices(indices)\n            \n\n            // using indices to delete corresponding tasks\n            const copy = [...data.tasks]\n            for (let i=indices.length-1; i>(-1);i--) {\n                copy.splice(indices[i],1)\n            }\n            setTasks(copy);\n\n        })\n\n        // destroy socket reference when the connection is closed\n        return () => {\n            socketRef.current.disconnect();\n        };\n    }, [roomId]);\n\n    //sends message to server that forwards to all users in room\n    const sendTask = (taskBody) => {\n        socketRef.current.emit(NEW_TASK_EVENT, {\n            body: taskBody,\n            senderId: socketRef.current.id,\n            statuses: statuses\n        });\n    }\n\n    // sends user Id to server\n    const sendId = (userId) => {\n        socketRef.current.emit(SENDING_USER_ID, {\n            userId: userId\n        });\n    }\n\n    //sends status change to server\n    const sendStatus = (index,statuses) => {\n        socketRef.current.emit(STATUS_CHANGE, {\n            index: index,\n            status: statuses,\n        })\n    }\n\n    //sends clear notif to server\n    const sendClear = (statuses,tasks) => {\n        socketRef.current.emit(CLEAR_COMPLETE, {\n            status: statuses,\n            tasks: tasks,\n        }) \n    }\n\n    // const populateTasks = (tasks) => {\n    //     socketRef.current.emit('populate', {\n    //         tasks:tasks,\n    //     })\n    // }\n\n\n    return {tasks, sendTask, statuses, sendStatus, sendClear}\n}\n\nexport default useList"]},"metadata":{},"sourceType":"module"}